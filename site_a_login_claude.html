<!DOCTYPE html>
<html>
<head>
  <title>Site A - Login</title>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
</head>
<body>
  <h1>ğŸ” Site A - Login</h1>
  <button id="loginButton">Entrar anonimamente</button>
  <button id="logoutButton" style="display:none;">Sair</button>
  <button id="syncButton" style="margin-left: 10px;">ğŸ”„ Sincronizar Estado</button>
  <p id="status">Status: Carregando...</p>
  <div id="logs" style="margin-top: 20px; padding: 10px; background: #f0f0f0; font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto;"></div>

  <script>
    const logDiv = document.getElementById('logs');
    
    function addLog(message) {
      const timestamp = new Date().toLocaleTimeString();
      const logMessage = `[${timestamp}] ${message}`;
      console.log(logMessage);
      logDiv.innerHTML += logMessage + '<br>';
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    addLog("[Site A] ğŸš€ Iniciando Site A...");

    let auth;
    let isReady = false;
    let currentUser = null;
    let authInitialized = false;

    // Detecta se estÃ¡ em iframe
    const isInIframe = window !== window.parent;
    addLog(`[Site A] ğŸ“± EstÃ¡ em iframe: ${isInIframe}`);

    // NOVA ESTRATÃ‰GIA: Storage personalizado para sync cross-frame
    const AUTH_STORAGE_KEY = 'firebase_auth_cross_frame_sync';
    const STORAGE_CHECK_INTERVAL = 1000; // 1 segundo

    fetch('https://broken-silence-aaa9.2gabrielekaline.workers.dev')
      .then(response => {
        addLog("[Site A] ğŸ“¡ Resposta da API recebida");
        return response.json();
      })
      .then(firebaseConfig => {
        addLog("[Site A] âš™ï¸ ConfiguraÃ§Ã£o Firebase recebida");
        addLog(`[Site A] ğŸ”‘ Project ID: ${firebaseConfig.projectId}`);
        
        firebase.initializeApp(firebaseConfig);
        auth = firebase.auth();
        addLog("[Site A] ğŸ”¥ Firebase inicializado");

        // ESTRATÃ‰GIA CRÃTICA: Usar persistÃªncia LOCAL + sincronizaÃ§Ã£o manual
        return firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL);
      })
      .then(() => {
        addLog("[Site A] ğŸ’¾ PersistÃªncia LOCAL configurada");
        
        // Inicia estratÃ©gias de sincronizaÃ§Ã£o
        setupCrossFrameSync();
        
        setTimeout(() => {
          setupAuthListener();
          forceInitialSync();
        }, 500);
        
        setupMessageListener();
      })
      .catch(error => {
        addLog(`[Site A] âŒ Erro na inicializaÃ§Ã£o: ${error.message}`);
        console.error("[Site A] Erro completo:", error);
      });

    // NOVA FUNÃ‡ÃƒO: ConfiguraÃ§Ã£o de sincronizaÃ§Ã£o cross-frame
    function setupCrossFrameSync() {
      addLog("[Site A] ğŸ”— Configurando sincronizaÃ§Ã£o cross-frame...");
      
      // Se estÃ¡ em iframe, verifica localStorage periodicamente
      if (isInIframe) {
        addLog("[Site A] ğŸ“± Modo iframe - configurando monitoramento de storage");
        
        setInterval(() => {
          checkStorageForAuthChanges();
        }, STORAGE_CHECK_INTERVAL);
        
        // ForÃ§a verificaÃ§Ã£o imediata
        setTimeout(() => {
          checkStorageForAuthChanges();
        }, 100);
      } else {
        addLog("[Site A] ğŸ–¥ï¸ Modo standalone - configurando escrita no storage");
        
        // Se nÃ£o estÃ¡ em iframe, monitora mudanÃ§as de auth e salva no storage
        window.addEventListener('storage', (e) => {
          if (e.key === AUTH_STORAGE_KEY && e.newValue) {
            addLog("[Site A] ğŸ“± MudanÃ§a detectada no storage de outro contexto");
            const authData = JSON.parse(e.newValue);
            processStorageAuthData(authData);
          }
        });
      }
    }

    // NOVA FUNÃ‡ÃƒO: Verifica storage para mudanÃ§as de auth
    function checkStorageForAuthChanges() {
      try {
        const storedAuth = localStorage.getItem(AUTH_STORAGE_KEY);
        if (storedAuth) {
          const authData = JSON.parse(storedAuth);
          
          // Verifica se hÃ¡ diferenÃ§a com o estado atual
          const currentUID = currentUser?.uid || null;
          const storedUID = authData.uid || null;
          
          if (currentUID !== storedUID) {
            addLog(`[Site A] ğŸ”„ Storage sync: Current UID: ${currentUID}, Stored UID: ${storedUID}`);
            
            if (storedUID && !currentUID) {
              addLog("[Site A] ğŸ‰ Detectado login em outro contexto - sincronizando...");
              forceAuthFromStorage(authData);
            } else if (!storedUID && currentUID) {
              addLog("[Site A] ğŸšª Detectado logout em outro contexto - sincronizando...");
              forceLogoutFromStorage();
            }
          }
        }
      } catch (error) {
        addLog(`[Site A] âš ï¸ Erro ao verificar storage: ${error.message}`);
      }
    }

    // NOVA FUNÃ‡ÃƒO: Processa dados de auth do storage
    function processStorageAuthData(authData) {
      addLog(`[Site A] ğŸ“¦ Processando dados do storage: ${JSON.stringify(authData)}`);
      
      if (authData.uid && authData.uid !== currentUser?.uid) {
        addLog("[Site A] ğŸ”„ ForÃ§ando sincronizaÃ§Ã£o com dados do storage...");
        forceAuthFromStorage(authData);
      }
    }

    // NOVA FUNÃ‡ÃƒO: ForÃ§a auth baseado no storage
    async function forceAuthFromStorage(authData) {
      addLog("[Site A] ğŸ” ForÃ§ando autenticaÃ§Ã£o baseada no storage...");
      
      if (!authData.uid) {
        addLog("[Site A] âŒ Dados de auth invÃ¡lidos no storage");
        return;
      }
      
      try {
        // ESTRATÃ‰GIA 1: Tentar signInAnonymously se Ã© anÃ´nimo
        if (authData.isAnonymous) {
          addLog("[Site A] ğŸ”„ Tentando login anÃ´nimo para sincronizar...");
          
          const userCredential = await auth.signInAnonymously();
          const user = userCredential.user;
          
          addLog(`[Site A] âœ… Login de sincronizaÃ§Ã£o realizado - UID: ${user.uid}`);
          
          // Se o UID nÃ£o bate, significa que Ã© uma nova sessÃ£o anÃ´nima
          if (user.uid !== authData.uid) {
            addLog(`[Site A] âš ï¸ UIDs diferentes - Storage: ${authData.uid}, Atual: ${user.uid}`);
            // Atualiza storage com novo UID
            updateAuthStorage(user);
          }
          
          return user;
        }
        
        // ESTRATÃ‰GIA 2: Para outros tipos de auth, forÃ§ar reload
        addLog("[Site A] ğŸ”„ ForÃ§ando reload para sincronizar auth nÃ£o-anÃ´nima...");
        window.location.reload();
        
      } catch (error) {
        addLog(`[Site A] âŒ Erro ao forÃ§ar auth do storage: ${error.message}`);
      }
    }

    // NOVA FUNÃ‡ÃƒO: ForÃ§a logout baseado no storage
    function forceLogoutFromStorage() {
      addLog("[Site A] ğŸšª ForÃ§ando logout baseado no storage...");
      
      if (auth && currentUser) {
        auth.signOut()
          .then(() => {
            addLog("[Site A] âœ… Logout de sincronizaÃ§Ã£o realizado");
          })
          .catch((error) => {
            addLog(`[Site A] âŒ Erro no logout de sincronizaÃ§Ã£o: ${error.message}`);
          });
      }
    }

    // NOVA FUNÃ‡ÃƒO: Atualiza storage de auth
    function updateAuthStorage(user) {
      if (!isInIframe) { // SÃ³ atualiza storage se NÃƒO estÃ¡ em iframe
        try {
          const authData = {
            uid: user?.uid || null,
            isAnonymous: user?.isAnonymous || false,
            timestamp: new Date().toISOString(),
            context: 'standalone'
          };
          
          localStorage.setItem(AUTH_STORAGE_KEY, JSON.stringify(authData));
          addLog(`[Site A] ğŸ’¾ Storage atualizado: ${JSON.stringify(authData)}`);
        } catch (error) {
          addLog(`[Site A] âŒ Erro ao atualizar storage: ${error.message}`);
        }
      }
    }

    // NOVA FUNÃ‡ÃƒO: Limpa storage de auth
    function clearAuthStorage() {
      if (!isInIframe) { // SÃ³ limpa storage se NÃƒO estÃ¡ em iframe
        try {
          localStorage.removeItem(AUTH_STORAGE_KEY);
          addLog("[Site A] ğŸ—‘ï¸ Storage de auth limpo");
        } catch (error) {
          addLog(`[Site A] âŒ Erro ao limpar storage: ${error.message}`);
        }
      }
    }

    function setupAuthListener() {
      addLog("[Site A] ğŸ”§ Configurando listener de auth...");
      
      auth.onAuthStateChanged((user) => {
        addLog(`[Site A] ğŸ‘¤ Estado de auth mudou: ${user ? 'LOGADO' : 'DESLOGADO'}`);
        
        if (user) {
          addLog(`[Site A] ğŸ†” UID: ${user.uid}`);
          addLog(`[Site A] ğŸ” Ã‰ anÃ´nimo: ${user.isAnonymous}`);
          
          // Atualiza storage se nÃ£o estÃ¡ em iframe
          updateAuthStorage(user);
        } else {
          // Limpa storage se nÃ£o estÃ¡ em iframe
          clearAuthStorage();
        }
        
        currentUser = user;
        updateStatus(user);
        
        if (!authInitialized) {
          authInitialized = true;
          addLog("[Site A] âœ… Auth inicializado pela primeira vez");
        }
        
        if (!isReady) {
          isReady = true;
          addLog("[Site A] âœ… Firebase estÃ¡ pronto para comunicaÃ§Ã£o");
          
          if (isInIframe) {
            setTimeout(() => {
              notifySiteB();
            }, 100);
          }
        } else if (isInIframe) {
          setTimeout(() => {
            notifySiteB();
          }, 100);
        }
      });
    }

    // NOVA FUNÃ‡ÃƒO: SincronizaÃ§Ã£o inicial agressiva
    async function forceInitialSync() {
      addLog("[Site A] ğŸ¯ Iniciando sincronizaÃ§Ã£o inicial...");
      
      try {
        // Se estÃ¡ em iframe, verifica storage primeiro
        if (isInIframe) {
          addLog("[Site A] ğŸ“± Iframe mode - verificando storage para auth existente...");
          
          const storedAuth = localStorage.getItem(AUTH_STORAGE_KEY);
          if (storedAuth) {
            const authData = JSON.parse(storedAuth);
            addLog(`[Site A] ğŸ“¦ Dados encontrados no storage: ${JSON.stringify(authData)}`);
            
            // Se hÃ¡ auth no storage mas nÃ£o hÃ¡ usuÃ¡rio atual
            if (authData.uid && !auth.currentUser) {
              addLog("[Site A] ğŸ”„ ForÃ§ando sincronizaÃ§Ã£o com storage...");
              await forceAuthFromStorage(authData);
              return;
            }
          }
        }
        
        // EstratÃ©gia padrÃ£o de sincronizaÃ§Ã£o
        await performDeepAuthSync();
        
      } catch (error) {
        addLog(`[Site A] âŒ Erro na sincronizaÃ§Ã£o inicial: ${error.message}`);
      }
    }

    function notifySiteB() {
      addLog("[Site A] ğŸ“¤ Enviando siteAReady para Site B");
      try {
        const message = { 
          type: 'siteAReady',
          timestamp: new Date().toISOString(),
          currentUser: currentUser ? { 
            uid: currentUser.uid, 
            isAnonymous: currentUser.isAnonymous,
            authTime: currentUser.metadata?.lastSignInTime || null
          } : null,
          context: isInIframe ? 'iframe' : 'standalone',
          syncStrategy: 'cross-frame-storage'
        };
        
        addLog(`[Site A] ğŸ“‹ Dados enviados: ${JSON.stringify(message)}`);
        
        window.parent.postMessage(message, '*');
        addLog("[Site A] âœ… Mensagem siteAReady enviada com sucesso");
      } catch (error) {
        addLog(`[Site A] âŒ Erro ao enviar siteAReady: ${error.message}`);
      }
    }

    function setupMessageListener() {
      addLog("[Site A] ğŸ”— Configurando listener de mensagens");
      
      window.addEventListener("message", (event) => {
        addLog(`[Site A] ğŸ“¨ Mensagem recebida de: ${event.origin}`);
        addLog(`[Site A] ğŸ“„ Dados da mensagem: ${JSON.stringify(event.data)}`);

        if (!auth) {
          addLog("[Site A] âš ï¸ Auth nÃ£o disponÃ­vel, ignorando mensagem");
          return;
        }

        if (event.data && event.data.type === "checkLogin") {
          addLog("[Site A] ğŸ” SolicitaÃ§Ã£o de verificaÃ§Ã£o de login recebida");
          
          // ForÃ§a nova verificaÃ§Ã£o de storage antes de responder
          if (isInIframe) {
            checkStorageForAuthChanges();
          }
          
          setTimeout(() => {
            performDeepAuthSync()
              .then(() => {
                const user = auth.currentUser;
                addLog(`[Site A] ğŸ‘¤ UsuÃ¡rio atual apÃ³s deep sync: ${user ? user.uid : 'null'}`);
                
                const response = {
                  type: "loginStatus",
                  loggedIn: !!user,
                  uid: user?.uid || null,
                  isAnonymous: user?.isAnonymous || false,
                  timestamp: new Date().toISOString(),
                  context: isInIframe ? 'iframe' : 'standalone',
                  syncMethod: 'cross-frame-deep'
                };
                
                addLog(`[Site A] ğŸ“¤ Enviando resposta: ${JSON.stringify(response)}`);
                
                try {
                  event.source.postMessage(response, event.origin);
                  addLog("[Site A] âœ… Resposta enviada com sucesso");
                } catch (error) {
                  addLog(`[Site A] âŒ Erro ao enviar resposta: ${error.message}`);
                }
              })
              .catch((error) => {
                addLog(`[Site A] âŒ Erro na sincronizaÃ§Ã£o profunda: ${error.message}`);
              });
          }, 100);
          
        } else if (event.data && event.data.type === "forceDeepSync") {
          addLog("[Site A] ğŸ”¬ SolicitaÃ§Ã£o de sincronizaÃ§Ã£o deep recebida");
          
          forceInitialSync()
            .then(() => {
              addLog("[Site A] âœ… SincronizaÃ§Ã£o deep concluÃ­da");
            })
            .catch((error) => {
              addLog(`[Site A] âŒ Erro na sincronizaÃ§Ã£o deep: ${error.message}`);
            });
        } else {
          addLog(`[Site A] â“ Tipo de mensagem desconhecido: ${event.data?.type}`);
        }
      });
      
      addLog("[Site A] âœ… Listener de mensagens configurado");
    }

    async function performDeepAuthSync() {
      addLog("[Site A] ğŸ”¬ Iniciando sincronizaÃ§Ã£o profunda...");
      
      try {
        let user = auth.currentUser;
        addLog(`[Site A] ğŸ‘¤ UsuÃ¡rio atual: ${user ? user.uid : 'null'}`);
        
        // Se estÃ¡ em iframe e nÃ£o hÃ¡ usuÃ¡rio, tenta sincronizar do storage
        if (isInIframe && !user) {
          addLog("[Site A] ğŸ“± Iframe sem usuÃ¡rio - verificando storage...");
          
          const storedAuth = localStorage.getItem(AUTH_STORAGE_KEY);
          if (storedAuth) {
            const authData = JSON.parse(storedAuth);
            if (authData.uid) {
              addLog(`[Site A] ğŸ¯ Tentando sincronizar com UID do storage: ${authData.uid}`);
              await forceAuthFromStorage(authData);
              user = auth.currentUser;
            }
          }
        }
        
        if (!user) {
          addLog("[Site A] ğŸ”„ ForÃ§ando reload do estado de auth...");
          
          await Promise.race([
            new Promise((resolve) => {
              const unsubscribe = auth.onAuthStateChanged((newUser) => {
                if (newUser) {
                  addLog(`[Site A] âœ… UsuÃ¡rio detectado via state change: ${newUser.uid}`);
                  unsubscribe();
                  resolve(newUser);
                } else {
                  setTimeout(() => {
                    unsubscribe();
                    resolve(null);
                  }, 1000);
                }
              });
            }),
            
            new Promise((resolve) => {
              const unsubscribe = auth.onIdTokenChanged((newUser) => {
                if (newUser) {
                  addLog(`[Site A] âœ… UsuÃ¡rio detectado via token change: ${newUser.uid}`);
                  unsubscribe();
                  resolve(newUser);
                } else {
                  setTimeout(() => {
                    unsubscribe();
                    resolve(null);
                  }, 1000);
                }
              });
            }),
            
            new Promise((resolve) => {
              setTimeout(() => {
                addLog("[Site A] â° Timeout na sincronizaÃ§Ã£o profunda");
                resolve(null);
              }, 3000);
            })
          ]);
          
          user = auth.currentUser;
        }
        
        if (user) {
          addLog(`[Site A] ğŸ”‘ Verificando validade do token para ${user.uid}...`);
          try {
            const token = await user.getIdToken(true);
            addLog(`[Site A] âœ… Token vÃ¡lido obtido (${token.length} chars)`);
            currentUser = user;
            updateStatus(user);
          } catch (tokenError) {
            addLog(`[Site A] âŒ Erro ao obter token: ${tokenError.message}`);
          }
        }
        
        addLog("[Site A] ğŸ SincronizaÃ§Ã£o profunda concluÃ­da");
        return user;
        
      } catch (error) {
        addLog(`[Site A] ğŸ’¥ Erro na sincronizaÃ§Ã£o profunda: ${error.message}`);
        throw error;
      }
    }

    // Event listeners dos botÃµes
    document.getElementById("loginButton").addEventListener("click", () => {
      addLog("[Site A] ğŸ” Tentando fazer login anÃ´nimo");
      
      if (!auth) {
        addLog("[Site A] âŒ Firebase ainda nÃ£o carregou");
        alert("Firebase ainda nÃ£o carregou!");
        return;
      }
      
      auth.signInAnonymously()
        .then((userCredential) => {
          const user = userCredential.user;
          addLog(`[Site A] âœ… Login anÃ´nimo realizado com sucesso - UID: ${user.uid}`);
          currentUser = user;
          
          // Atualiza storage
          updateAuthStorage(user);
          
          if (isInIframe) {
            setTimeout(() => {
              addLog("[Site A] ğŸ“¢ Notificando Site B sobre novo login");
              notifySiteB();
            }, 100);
          }
        })
        .catch(error => {
          addLog(`[Site A] âŒ Erro no login: ${error.message}`);
          console.error("[Site A] Erro completo no login:", error);
        });
    });

    document.getElementById("logoutButton").addEventListener("click", () => {
      addLog("[Site A] ğŸšª Fazendo logout");
      
      auth.signOut()
        .then(() => {
          addLog("[Site A] âœ… Logout realizado com sucesso");
          currentUser = null;
          
          // Limpa storage
          clearAuthStorage();
          
          if (isInIframe) {
            setTimeout(() => {
              addLog("[Site A] ğŸ“¢ Notificando Site B sobre logout");
              notifySiteB();
            }, 100);
          }
        })
        .catch(error => {
          addLog(`[Site A] âŒ Erro no logout: ${error.message}`);
        });
    });

    document.getElementById("syncButton").addEventListener("click", () => {
      addLog("[Site A] ğŸ”„ SincronizaÃ§Ã£o manual solicitada");
      forceInitialSync()
        .then((user) => {
          if (user) {
            addLog(`[Site A] âœ… ApÃ³s sincronizaÃ§Ã£o manual - UsuÃ¡rio: ${user.uid}`);
          } else {
            addLog("[Site A] âŒ ApÃ³s sincronizaÃ§Ã£o manual - Nenhum usuÃ¡rio");
          }
        })
        .catch((error) => {
          addLog(`[Site A] âŒ Erro na sincronizaÃ§Ã£o manual: ${error.message}`);
        });
    });

    function updateStatus(user) {
      const statusEl = document.getElementById("status");
      const loginBtn = document.getElementById("loginButton");
      const logoutBtn = document.getElementById("logoutButton");
      
      if (user) {
        addLog(`[Site A] ğŸ‘¤ UsuÃ¡rio logado - UID: ${user.uid} | AnÃ´nimo: ${user.isAnonymous}`);
        statusEl.innerText = `Status: Logado! (${user.uid.substring(0, 8)}...)`;
        statusEl.style.color = "green";
        loginBtn.style.display = "none";
        logoutBtn.style.display = "inline-block";
      } else {
        addLog("[Site A] ğŸš« Nenhum usuÃ¡rio logado");
        statusEl.innerText = "Status: NÃ£o logado";
        statusEl.style.color = "red";
        loginBtn.style.display = "inline-block";
        logoutBtn.style.display = "none";
      }
    }

    window.addEventListener('load', () => {
      addLog("[Site A] ğŸ“„ PÃ¡gina totalmente carregada");
    });

    window.addEventListener('error', (event) => {
      addLog(`[Site A] ğŸ’¥ Erro JavaScript: ${event.message} em ${event.filename}:${event.lineno}`);
    });

    // Monitoramento periÃ³dico se estiver em iframe
    if (isInIframe) {
      addLog("[Site A] â° Configurando verificaÃ§Ã£o periÃ³dica (iframe mode)");
      
      setInterval(() => {
        const user = auth && auth.currentUser;
        if (user && (!currentUser || currentUser.uid !== user.uid)) {
          addLog(`[Site A] ğŸ”„ SincronizaÃ§Ã£o periÃ³dica detectou mudanÃ§a: ${user.uid}`);
          currentUser = user;
          updateStatus(user);
          notifySiteB();
        }
      }, 2000);
    }

    addLog("[Site A] âœ… Site A com sincronizaÃ§Ã£o cross-frame iniciado");
  </script>
</body>
</html>
